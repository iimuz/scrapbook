[{"content":"概要 docker\rに関するメモを記載します。\nChange Remote Docker Host docker のリモートホストを変更する場合は、下記方法で Remote Host を設定します。\n settings.json の docker.host  tcp 接続の場合: tcp://localhost:2375 ssh 接続の場合: ssh://user@ip    ssh 接続もできるようですが、 2020.2.13 時点では正常に接続できませんでした。 ssh agent にキーを登録する必要がありそうな感じです。 .ssh/config の設定は読んでくれないのかもしれません。\nMacOS における Dockerfile の UID 対象となる環境が正確には不明だが、下記の環境において、Dockerfile 内でユーザーを作成するとユーザーを作成したレイヤーのサイズが極端に大きく(200GB)くらいと判定される状態になることを確認した。(実際に消費されているわけではないようだが docker image ls で容量を確認すると非常に大きくなる。また、image をビルドした段階で最終工程でエクスポートする時に非常に時間がかかる。)\n MacOS Ventura 13.2 Rancher Desktop (dockerd moby)  Dockerfile\n1 2 3 4 5 6 7 8 9 10 11 12 13  FROMubuntu:22.04ARG USERNAME=dev ARG USER_GID=1000 ARG USER_UID=1000 ENV DEBIAN_FRONTEND=noninteractive RUN groupadd --gid $USER_GID $USERNAME \\  \u0026amp;\u0026amp; useradd --uid $USER_UID --gid $USER_GID -m $USERNAMEENV DEBIAN_FRONTEND=dialog USER$USERNAME  上記のようなファイルを用意して、 USER_GID に MacOS の UID (=lima の UID) を割り当てると作成したレイヤーが大きくなる。\n1  docker build --build-arg USER_UID=$(id -u) -t hoge   MacOS の場合は、root 権限で実行したコンテナ内でホストをマウントした領域にファイルを作成してもユーザ ID などは良しなに設定してくれる。そのためテキトウに 1000 などと指定して実行しても問題なく、 docker image ls の容量も正常になった。\n","permalink":"https://iimuz.github.io/scrapbook/zettelkasten/scrapbook-20230103171358/","summary":"概要 docker\rに関するメモを記載します。\nChange Remote Docker Host docker のリモートホストを変更する場合は、下記方法で Remote Host を設定します。\n settings.json の docker.host  tcp 接続の場合: tcp://localhost:2375 ssh 接続の場合: ssh://user@ip    ssh 接続もできるようですが、 2020.2.13 時点では正常に接続できませんでした。 ssh agent にキーを登録する必要がありそうな感じです。 .ssh/config の設定は読んでくれないのかもしれません。\nMacOS における Dockerfile の UID 対象となる環境が正確には不明だが、下記の環境において、Dockerfile 内でユーザーを作成するとユーザーを作成したレイヤーのサイズが極端に大きく(200GB)くらいと判定される状態になることを確認した。(実際に消費されているわけではないようだが docker image ls で容量を確認すると非常に大きくなる。また、image をビルドした段階で最終工程でエクスポートする時に非常に時間がかかる。)\n MacOS Ventura 13.2 Rancher Desktop (dockerd moby)  Dockerfile\n1 2 3 4 5 6 7 8 9 10 11 12 13  FROMubuntu:22.","title":"Docker Tips"},{"content":"概要  Jupyter\r  マジックコマンドを python コードとして記述 jupyter を利用しているとマジックコマンドが利用できる。 例えば、下記のようなマジックコマンドを利用することで、モジュールの再読み込みが可能になる。\n1 2  %load_ext autoreload %autoreload 2   上記のように記述した場合、python スクリプトとしては構文エラーとなり formatter などをファイル一括で適用できないことがある。(上記の部分でエラーとなり、それ以降を formatter が修正できない。) その場合は、下記のように記述することで関数呼び出しとなり、全体を formmater が修正できる。\n1 2 3 4  from IPython import get_ipython get_ipython().run_line_magic(\u0026#34;load_ext\u0026#34;, \u0026#34;autoreload\u0026#34;) get_ipython().run_line_magic(\u0026#34;autoreload\u0026#34;, \u0026#34;2\u0026#34;)   ","permalink":"https://iimuz.github.io/scrapbook/zettelkasten/scrapbook-20221219094136/","summary":"概要  Jupyter\r  マジックコマンドを python コードとして記述 jupyter を利用しているとマジックコマンドが利用できる。 例えば、下記のようなマジックコマンドを利用することで、モジュールの再読み込みが可能になる。\n1 2  %load_ext autoreload %autoreload 2   上記のように記述した場合、python スクリプトとしては構文エラーとなり formatter などをファイル一括で適用できないことがある。(上記の部分でエラーとなり、それ以降を formatter が修正できない。) その場合は、下記のように記述することで関数呼び出しとなり、全体を formmater が修正できる。\n1 2 3 4  from IPython import get_ipython get_ipython().run_line_magic(\u0026#34;load_ext\u0026#34;, \u0026#34;autoreload\u0026#34;) get_ipython().run_line_magic(\u0026#34;autoreload\u0026#34;, \u0026#34;2\u0026#34;)   ","title":"Jupyter Tips"},{"content":"概要  Homebrew\r  パッケージマネージャーとして WSL2 環境に Homebrew を導入。\nInstall homebrew   apt install build-essential\n  Homebrew\rのトップにあるインストールコマンドを実行。\n  コマンド実行後に下記を実行するように出力があるので実行する。\n1 2 3 4  echo \u0026#39;# Set PATH, MANPATH, etc., for Homebrew.\u0026#39; \u0026gt;\u0026gt; /home/$USER/.profile echo \u0026#39;eval \u0026#34;$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\u0026#34;\u0026#39; \u0026gt;\u0026gt; /home/$USER/.profile eval \u0026#34;$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\u0026#34; brew install gcc # recommended    上記だと出力先は .profile になっているが、環境として .bashrc を読み込むようにしており、設定を .bashrc にまとめているので書き込む先を修正。 加えて、他の設定よりも先に読み込むように修正しておく。    シェルの再起動を実行: exec $SHELL -l\n  動作確認: brew --version\n  homebrew bundle  homebrew bundle\r: brew でインストールしたソフトウェアを Brewfile というファイルで管理できる。  homebrew でインストールした既存の環境は、 brew bundle dump コマンドで一括で Brewfile に書き出すことができ管理下に置くことができる。 よくつかいそうなコマンドは下記の通り。\n brew bundle [package]: package で指定したソフトウェアをインストールする。 brew bundle cleanup: Brewfile で管理されていないソフトウェアを削除する。  Brewfile の場所は --file オプションで設定するか、 HOMEBREW_BUNDLE_FILE 環境変数で設定する。\n個人環境におけるソフトウェアのインストール状況は下記のファイルとなる。\n GitHub iimuz/dotfiles/.config/homebrew/Brewfile\r  brew インストールしたファイルの置き場所 brew インストールした場合、下記のフォルダにファイルが配置される。 brew install したパッケージに加えて brew 自体も同フォルダに保存されている。\n /home/linuxbrew/.linuxbrew/bin  ","permalink":"https://iimuz.github.io/scrapbook/zettelkasten/scrapbook-20221218142420/","summary":"概要  Homebrew\r  パッケージマネージャーとして WSL2 環境に Homebrew を導入。\nInstall homebrew   apt install build-essential\n  Homebrew\rのトップにあるインストールコマンドを実行。\n  コマンド実行後に下記を実行するように出力があるので実行する。\n1 2 3 4  echo \u0026#39;# Set PATH, MANPATH, etc., for Homebrew.\u0026#39; \u0026gt;\u0026gt; /home/$USER/.profile echo \u0026#39;eval \u0026#34;$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\u0026#34;\u0026#39; \u0026gt;\u0026gt; /home/$USER/.profile eval \u0026#34;$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\u0026#34; brew install gcc # recommended    上記だと出力先は .profile になっているが、環境として .bashrc を読み込むようにしており、設定を .bashrc にまとめているので書き込む先を修正。 加えて、他の設定よりも先に読み込むように修正しておく。    シェルの再起動を実行: exec $SHELL -l","title":"Homebrew Tips"},{"content":"概要  Scoop\r  install Scoop Quickstat\rによれば下記のコマンドでインストールできる。 一つ目は optinal なので 2 行目が実行できれば使わなくてもよい。\n1 2  Set-ExecutionPolicy RemoteSigned -Scope CurrentUser irm get.scoop.sh | iex   extras bucket の追加 VSCode などをインストールするために必要。 bucket を追加するために git が必要になるので事前にインストールする。\n1 2  scoop install git scoop bucket add extras   パッケージ一覧の export, import scoop で導入しているパッケージの一覧を export し別の環境で import するには、json ファイルを出力して取り込めばよい。\n1 2  scoop export -c \u0026gt; scoopfile.json scoop import scoopfile.json   個人環境における scoop export の結果は下記のファイルとなる。\n GitHub iimuz/dotfiles/.config/scoop/scoopfile.json\r  ","permalink":"https://iimuz.github.io/scrapbook/zettelkasten/scrapbook-20221217120338/","summary":"概要  Scoop\r  install Scoop Quickstat\rによれば下記のコマンドでインストールできる。 一つ目は optinal なので 2 行目が実行できれば使わなくてもよい。\n1 2  Set-ExecutionPolicy RemoteSigned -Scope CurrentUser irm get.scoop.sh | iex   extras bucket の追加 VSCode などをインストールするために必要。 bucket を追加するために git が必要になるので事前にインストールする。\n1 2  scoop install git scoop bucket add extras   パッケージ一覧の export, import scoop で導入しているパッケージの一覧を export し別の環境で import するには、json ファイルを出力して取り込めばよい。\n1 2  scoop export -c \u0026gt; scoopfile.json scoop import scoopfile.json   個人環境における scoop export の結果は下記のファイルとなる。","title":"Scoop Tips"},{"content":"ネットワークの一部のみを適用する How to load part of pre trained model?\rより下記の方法で feature 層のみ読み込める。\n1 2 3 4 5 6 7 8 9 10  # 学習済みモデルの読み込み pretrained_dict = torch.load(PATH) model = TheModelClass(*args, **kwargs) model_dict = model.state_dict() # 適用対象のモデルにない層を削除 pretrained_dict = {k: v for k, v in pretrained_dict.items() if k in model_dict} # 適用したい対象のモデルの一致する層を上書き model_dict.update(pretrained_dict) # 上書きしたモデルを読み込む model.load_state_dict(model_dict)   ","permalink":"https://iimuz.github.io/scrapbook/zettelkasten/scrapbook-20221215132013/","summary":"ネットワークの一部のみを適用する How to load part of pre trained model?\rより下記の方法で feature 層のみ読み込める。\n1 2 3 4 5 6 7 8 9 10  # 学習済みモデルの読み込み pretrained_dict = torch.load(PATH) model = TheModelClass(*args, **kwargs) model_dict = model.state_dict() # 適用対象のモデルにない層を削除 pretrained_dict = {k: v for k, v in pretrained_dict.items() if k in model_dict} # 適用したい対象のモデルの一致する層を上書き model_dict.update(pretrained_dict) # 上書きしたモデルを読み込む model.load_state_dict(model_dict)   ","title":"PyTorch Tips"},{"content":"sparse-checkout 既存リポジトリに sparse-checkout を適用する場合。\n1 2 3 4 5 6 7 8 9  # 初期化 git sparse-checkout init --cone # checkoutする対象フォルダの設定 git sparse-checkout set path/to/checkout/direcotry # 既存の設定を上書きする場合 git sparse-checkout add path/to/checkout/direcotry # 既存の設定に追加する場合 # checkout対象の確認 git sparse-checkout list   git submodule でリポジトリの一部だけを利用する(sparse checkout)\rバージョンの都合などにより git sparse-checkout add が利用できない場合、 .git/info/sparse-checkout を直接編集して適用することができる。直接編集の場合は、下記コマンドを実行して編集結果を反映する必要がある。\n1  git read-tree -mu HEAD   Creating sparse checkout in a new linked git worktree\rworktree を併用している場合、 .git/info/sparse-checkout ファイルの場所は、 .git/worktree/\u0026lt;id\u0026gt;/info/sparse-checkout になる。 また、worktree 用の info フォルダは自動で生成されない。そのため、下記の手順のように info フォルダを自分で作成する必要がある。\n1 2 3 4 5  git worktree add /path/to/worktree {branch} mkdir .git/worktree/{id}/info cd /path/to/worktree git sparse-checkout init --cone # 移行は普通の使い方と同じ   git リポジトリのバックアップとリストア リポジトリをローカルに圧縮して保存しておく方法。他のホスティングサービスに移行する場合や、単にアーカイブを作成する用途に使える。\n1 2 3 4 5 6 7 8 9 10  # バックアップ用に.gitのみを取得 git clone --mirror git@github/path/to/repo/repo.git /path/to/repo.git git lfs fetch --all # lfsがある場合 tar -zcf /path/to/archive.tar.gz /path/to/repo.git # 圧縮 # リストア cd /path/to/repo.git git remote add --mirror=push origin git@path.to.repo git push origin git lfs push --all # lfsがある場合    参考資料  git リポジトリ単位で バックアップ、アーカイブ、リカバリ\r GitLFS を使ったリポジトリのバックアップとリストア\r    ","permalink":"https://iimuz.github.io/scrapbook/zettelkasten/scrapbook-20221127091453/","summary":"sparse-checkout 既存リポジトリに sparse-checkout を適用する場合。\n1 2 3 4 5 6 7 8 9  # 初期化 git sparse-checkout init --cone # checkoutする対象フォルダの設定 git sparse-checkout set path/to/checkout/direcotry # 既存の設定を上書きする場合 git sparse-checkout add path/to/checkout/direcotry # 既存の設定に追加する場合 # checkout対象の確認 git sparse-checkout list   git submodule でリポジトリの一部だけを利用する(sparse checkout)\rバージョンの都合などにより git sparse-checkout add が利用できない場合、 .git/info/sparse-checkout を直接編集して適用することができる。直接編集の場合は、下記コマンドを実行して編集結果を反映する必要がある。\n1  git read-tree -mu HEAD   Creating sparse checkout in a new linked git worktree\rworktree を併用している場合、 .","title":"Git Tips"},{"content":"Javascript における空文字列の Boolean 判定 Javascript では空文字列に対する Boolean は必ず false になる。\n In javascript, is an empty string always false as a boolean?\r  ","permalink":"https://iimuz.github.io/scrapbook/zettelkasten/scrapbook-20220825214534/","summary":"Javascript における空文字列の Boolean 判定 Javascript では空文字列に対する Boolean は必ず false になる。\n In javascript, is an empty string always false as a boolean?\r  ","title":"Javascript Tips"},{"content":"Typescript の Utility Types Partialを利用すると全変数を任意のパラメータにした型を取得できる。\n 【TypeScript】Utility Types をまとめて理解する\r  ","permalink":"https://iimuz.github.io/scrapbook/zettelkasten/scrapbook-20220825214849/","summary":"Typescript の Utility Types Partialを利用すると全変数を任意のパラメータにした型を取得できる。\n 【TypeScript】Utility Types をまとめて理解する\r  ","title":"Typescript Tips"},{"content":"ファイル数カウント ファイル数をカウントする方法です。 find を利用しているためディレクトリ以下を再帰的に探索します。\n1  find /path/to/dir -type f | wc -l   参考資料\n 2013.10.2 Qiita ディレクトリ内のファイル数をカウントする\r  ","permalink":"https://iimuz.github.io/scrapbook/zettelkasten/scrapbook-20220702144802/","summary":"ファイル数カウント ファイル数をカウントする方法です。 find を利用しているためディレクトリ以下を再帰的に探索します。\n1  find /path/to/dir -type f | wc -l   参考資料\n 2013.10.2 Qiita ディレクトリ内のファイル数をカウントする\r  ","title":"Bash Tips"},{"content":"アカウント切り替え 1  gcloud config configurations activate hoge   切り替え用アカウントの作成 1 2 3 4 5 6 7 8 9 10  gcloud config configurations create hoge gcloud config configurations activate hoge # 設定の作成 gcloud config set compute/region asia-northeast1 gcloud config set compute/zone asia-northeast1-a gcloud config set core/account hoge@example.com gcloud config set core/project hoge-project gcloud config set core/disable_usage_reporting False # 設定を作った後に認証が必要なため認証は実行しておく gcloud auth login   compute instance のイメージ名一覧 1  gcloud compute images list   GCE の home だけ別のディスクをマウント home 下に別のディスクをマウントする方法です。 想定としては、 Google Cloud Shell の自分用のような感じです。 基本的に使わないときは、 VM を削除して節約し、使うときにだけ VM を必要なインスタンスで生成します。 Google Cloud Shell だとホームディレクトリに 5GB しかなく、 ルート下 6GB 程度しかないため、 docker を使うと簡単に容量が足りなくなります。 それの代替手段として利用することを想定しています。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  # home directory にするディスクの作成 # 必要ならばあとで大きくすればいいので、とりあえずのサイズで作る。 DISK_NAME=hoge-disk gcloud compute disks create $DISK_NAME \\  --size 10 \\  --type pd-standard # 作成したディスクはフォーマットが必要なため、ディスクをマウントした VM 上で下記を実行します。 INSTANCE_NAME=dev MACHINE_TYPE=n1-standard-1 DISK_SIZE=30GB gcloud compute \\  instances create $INSTANCE_NAME \\  --machine-type=$MACHINE_TYPE \\  --subnet=default \\  --network-tier=PREMIUM \\  --no-restart-on-failure \\  --maintenance-policy=TERMINATE \\  --preemptible \\  --image=ubuntu-1804-bionic-v20200108 \\  --image-project=ubuntu-os-cloud \\  --boot-disk-size=$DISK_SIZE \\  --boot-disk-type=pd-standard \\  --boot-disk-device-name=$INSTANCE_NAME \\  --disk=name=$DISK_NAME,device-name=$DISK_NAME,mode=rw,boot=no sudo lsblk # ディスクのデバイス ID 確認 DEVICE_ID=sdb DEVICE_UUID=`sudo blkid -s UUID -o value /dev/$DEVICE_ID` sudo mkfs.ext4 -m 0 -E lazy_itable_init=0,lazy_journal_init=0,discard /dev/$DEVICE_ID # 初回のみディスクの内容を HOME からコピーします。 sudo mkdir -p /mnt/disks/$DISK_NAME sudo mount -o discard,defaults /dev/$DEVICE_ID /mnt/disks/$DISK_NAME sudo rsync -av /home/ /mnt/disks/$DISK_NAME # ディスクを HOME としてマウントするように設定して再起動します。 sudo rm -rf /home/* echo UUID=$DEVICE_UUID /home ext4 discard,defaults,nofail 0 2 | sudo tee -a /etc/fstab udo reboot   ","permalink":"https://iimuz.github.io/scrapbook/zettelkasten/scrapbook-20220702151015/","summary":"アカウント切り替え 1  gcloud config configurations activate hoge   切り替え用アカウントの作成 1 2 3 4 5 6 7 8 9 10  gcloud config configurations create hoge gcloud config configurations activate hoge # 設定の作成 gcloud config set compute/region asia-northeast1 gcloud config set compute/zone asia-northeast1-a gcloud config set core/account hoge@example.com gcloud config set core/project hoge-project gcloud config set core/disable_usage_reporting False # 設定を作った後に認証が必要なため認証は実行しておく gcloud auth login   compute instance のイメージ名一覧 1  gcloud compute images list   GCE の home だけ別のディスクをマウント home 下に別のディスクをマウントする方法です。 想定としては、 Google Cloud Shell の自分用のような感じです。 基本的に使わないときは、 VM を削除して節約し、使うときにだけ VM を必要なインスタンスで生成します。 Google Cloud Shell だとホームディレクトリに 5GB しかなく、 ルート下 6GB 程度しかないため、 docker を使うと簡単に容量が足りなくなります。 それの代替手段として利用することを想定しています。","title":"GCP Tips"}]