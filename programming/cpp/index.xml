<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C/C&#43;&#43; on しさく</title>
    <link>https://iimuz.github.io/scrapbook/programming/cpp/</link>
    <description>Recent content in C/C&#43;&#43; on しさく</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://iimuz.github.io/scrapbook/programming/cpp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>gcc でライブラリを静的リンクする方法</title>
      <link>https://iimuz.github.io/scrapbook/programming/cpp/gcc-static-link/</link>
      <pubDate>Tue, 16 Oct 2018 21:30:34 +0900</pubDate>
      
      <guid>https://iimuz.github.io/scrapbook/programming/cpp/gcc-static-link/</guid>
      <description>ライブラリを動的リンクではなく、強制的に静的リンクをしてしまいたい場合があります。 そういう時は、 gcc のオプションで &amp;ndash;static を利用します。 pkg-config を利用している場合は、 pkg-config が対応していれば、 下記のように記載することで適切に処理してくれます。
`pkg-config --static hoge` ただ、 pkg-config が対応してない場合もあるため、 対応していない場合は、下記のように直前に &amp;ndash;static を記載しても静的リンクできるようです。
--static `pkg-config hoge` 参考文献: How to use pkg-config to link a library statically</description>
    </item>
    
    <item>
      <title>windows で c&#43;&#43; を用いてメモリ使用量を取得する</title>
      <link>https://iimuz.github.io/scrapbook/programming/cpp/cpp-windows-memory-usage/</link>
      <pubDate>Sat, 08 Sep 2018 14:25:09 +0900</pubDate>
      
      <guid>https://iimuz.github.io/scrapbook/programming/cpp/cpp-windows-memory-usage/</guid>
      <description>windows 環境において、 コード中の特定位置で現在のプロセスが利用しているメモリ使用量を取得したかったので、 調べた時のメモです。
結論 windows.h と psapi.h を利用して、 PROCESS_MEMORY_COUNTERS_EX という構造体にメモリ使用量が取得できます。 psapi.h は psapi.lib をリンクする必要がありましたが、 下記のようなコードで構造体中にメモリ使用量を取得できます。
 GetProcessMemoryInfo メモリを取得する際には、 GetProcessMemoryInfo という関数を利用します。 GetProcessMemoryInfo は、プロセスのハンドルを渡す必要があります。 実際に作った exe を動かし、その時のメモリ情報を必要とする場合は、 GetCurrentProcess で取得できます。
一方で、他のプロセスのハンドルを取得すれば、そのプロセスのメモリを取得することも可能です。 ただ、多くの場合はリソースモニタとかで取得したり記録しておけば十分な気もします。
PROCESS_MEMORY_COUNTERS_EX メモリ情報は PROCESS_MEMORY_COUNTERS_EX という構造体に取得できます。 結構色々取得できるのですが、 private usage を取得しておけば、 とりあえずのメモリ量監視としては十分な気がします。
各種用語の開設に関しては、下記が非常に参考になりました。
Windows の使われてるメモリの量
visual studio でのお試しプロジェクト 動作テストのために、 Visual Studio 2010 と古いですが、プロジェクトを作成したサンプルを置いておきます。
 iimuz/visualstudio-private-bytes-sample  </description>
    </item>
    
    <item>
      <title>c&#43;&#43; の std::unique_ptr におけるデリータ指定</title>
      <link>https://iimuz.github.io/scrapbook/programming/cpp/cpp-unique-ptr-deleter/</link>
      <pubDate>Sun, 02 Sep 2018 11:38:40 +0900</pubDate>
      
      <guid>https://iimuz.github.io/scrapbook/programming/cpp/cpp-unique-ptr-deleter/</guid>
      <description>win32api を利用するときに CreateHandle は CloseHandle を呼部必要のある Handle を返すのですが、 Handle 型で返すために単純に std::unique_ptr でいつも通りのデリータを指定することができませんでした。
std::unique_ptr, deleters and the Win32 API によると、 CreateHandle のようにポインタ以外が帰ってきてしまう場合に std::unique_ptr を利用したい場合は、 下記のように関数オブジェクトを定義してデリータに指定すると利用できることが分かりました。
 普通にポインタを返してくれるタイプであれば、 デリータ指定自体は、一般的には下記の方法が利用できるはずです。
関数オブジェクト
 default_delete の特殊化
 関数
 状況により使い分けは必要ですが、関数版が一番記述量が少なくて好きです。 default_delete の特殊化は、どこに書くべきなのかがよくわからなくて、使ったことがないです。 cpp ファイルの方に書くと、必要なところで毎回記述が必要になります。 自作クラスならヘッダファイルに宣言して、 cpp に実体を記述することもできますが、 自作クラスを std::unique_ptr で利用する前提で書くのも何かなと思ったりします。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;で利用できそうなLoggerを調べました</title>
      <link>https://iimuz.github.io/scrapbook/programming/cpp/cpplogger/</link>
      <pubDate>Wed, 16 Nov 2016 23:51:59 +0900</pubDate>
      
      <guid>https://iimuz.github.io/scrapbook/programming/cpp/cpplogger/</guid>
      <description>利用できそうなLogger  Plog - portable and simple log for C++  ヘッダファイルのみで構成されているLoggerです。 License: Mozilla Public Lisense 2.0   log4cxx glog Boost.Log EasyLogging++ spdlog  License: MIT License    各Loggerのちょっとしたメモ Plog 2016/11/16現在でも更新されています。 ヘッダファイルだけで構成されているため、cloneしてパスを通せば利用できそうです。 利用方法については、Qiitaで記事が書かれていたので、こちらを参照してください。
spdlog 2016/11/16現在も更新されています。 Plog同様にヘッダファイルのみで構成されているようです。 処理速度重視のようです。 利用方法については、ブログに記事がありましたので、こちらを参照してください。</description>
    </item>
    
  </channel>
</rss>